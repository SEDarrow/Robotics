#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  HTServo)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     SMUX,           sensorI2CCustom)
#pragma config(Sensor, S3,     HTSPB,          sensorI2CCustom)
#pragma config(Sensor, S4,     HTGYRO,         sensorI2CCustom)
#pragma config(Motor,  motorA,          Green,         tmotorNXT, openLoop)
#pragma config(Motor,  motorB,          Yellow,        tmotorNXT, openLoop)
#pragma config(Motor,  motorC,          A,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     Shoot,         tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     Lift,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     Left1,         tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     Right1,        tmotorTetrix, openLoop, encoder)
#pragma config(Servo,  srvo_S1_C3_1,    Jumper,               tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    S,             tServoStandard)
#pragma config(Servo,  srvo_S1_C3_3,    Door,                 tServoStandard)
#pragma config(Servo,  srvo_S1_C3_4,    Spout,            tServoStandard)
#pragma config(Servo,  srvo_S1_C3_5,    LeftLatch,            tServoStandard)
#pragma config(Servo,  srvo_S1_C3_6,    RightLatch,           tServoStandard)
#pragma config(Servo,  srvo_S1_C4_1,    IRBeam,              			 tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    a,                    tServoStandard)
#pragma config(Servo,  srvo_S1_C4_3,    Latch,                tServoStandard)
#pragma config(Servo,  srvo_S1_C4_4,    servo4,               tServoStandard)
#pragma config(Servo,  srvo_S1_C4_5,    LeftLatch,            tServoStandard)
#pragma config(Servo,  srvo_S1_C4_6,    RightLatch,           tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"
#include "drivers/common.h"
#include "drivers/hitechnic-sensormux.h"
#include "drivers/lego-ultrasound.h"
#include "drivers/hitechnic-irseeker-v2.h"
#include "drivers/hitechnic-gyro.h"
#include "drivers/hitechnic-colour-v2.h"
#include "drivers/hitechnic-eopd.h"
#include "drivers/hitechnic-accelerometer.h"
#include "drivers/hitechnic-superpro.h"

#define GearRatioAdjustment 1.0             		 //adjust to gear ratio
#define Four_Inch_Diameter (3.98/GearRatioAdjustment)//diameter of the 4 inch wheels
#define circumference (3.14 * 3.98)					 //calculating the circumference (of the 4 inch wheels)
#define Degrees2Inches (3.14/GearRatioAdjustment)    //degrees in an inch
#define GearRatio (1.0)
#define GYRO_RATE_ADJUSTMENT    0.98 				 // in degrees per second

const tMUXSensor HTAC = msensor_S2_2;
const tMUXSensor LEGOUS = msensor_S2_3;
const tMUXSensor HTIR = msensor_S2_4;

bool DelaySelected = false;
bool StartSelected = false;
bool DefenseSelected = false;
bool Defended = false;
float LastDirection = 0.0;
bool Defense;
int CenterPos = 0;
int Delay = 0;
int nExitButton  = 0;
int nNoButton    = 0;

typedef enum {IRDetected, Regular, MotorStopped} ExitState;
typedef enum {Left, Right} Direction;
typedef enum {Robot, Gyro, Compass, Colour, IR} State;
typedef enum {Open, Closed} LatchState;
long LastEncoderValueLeft = -1;
long LastEncoderValueRight = -1;

typedef enum StartState{ramp,ground};
StartState Start = ground;

//
// Returns an angle that is within -179 to 180 degrees
//
float FixDirection (float Angle)
{ // FixDirection
	float NewAngle;

	if (Angle > 180.0)
		NewAngle = Angle - 360.0;
	else if (Angle < -180.0)
		NewAngle = Angle + 360.0;
	else
		NewAngle = Angle;
	return NewAngle;
} // end FixDirection

//
//Uses gyro sensor to determine heading
//
float GetAngle()
{
	if(abs(HTGYROreadRot(HTGYRO))>2)
	{ //if robot is turning
		
		//calculate amount turned
		float CurrLookDirection = LastDirection + ((float)(HTGYROreadRot(HTGYRO)-1)*(float)time1(T1)/1000.0);
		ClearTimer(T1);
		
		//save current heading for future use
		LastDirection = FixDirection(CurrLookDirection);
		
		return CurrLookDirection;
	}
	else
	{
		ClearTimer(T1);
		return LastDirection;
	}
}

//
//Halts program until NXT center button pressed
//For debugging purposes
//
void WaitForButton(void)
{
	TButtons nBtn;

	while (true) // wait for button press
	{
		nBtn = nNxtButtonPressed;
		if (nBtn == kEnterButton)
			break;
	}
}

//
//Stop wheels on robot
//
void StopMotors()
{
	motor[Right1] = 0;
	motor[Left1] = 0;
}

//
//Opens and closes the latches on the robot
//
void MoveLatches(LatchState Direction)
{
	if(Direction == Open)
	{
		servo[LeftLatch] = 180;
		servo[RightLatch] = 40;
	}
	else
	{
		servo[RightLatch] = 154;
		servo[LeftLatch] = 75;
	}
}


//
//Drives staying a certain distance from a wall
//Uses two ultrasonic sensors mounted on the side of the robot
//
void SideUltrasonicDriving(int speed, float distance, float space)
{
	distance = 1120.0 * distance / circumference; //converts inches to encoder values
	nMotorEncoder[Right1] = 0;
	
	//Getting initial ultrasonic values in inches
	float FrontUS = HTSPBreadADC(HTSPB, 2, 10)/1023.0*3.3*1000.0/6.4;
	float BackUS = HTSPBreadADC(HTSPB, 3, 10)/1023.0*3.3*1000.0/6.4;
	
	float dist;
	float angle;
	float ASensitivity  = 35.0;
	float DSensitivity = 35.0;

	if(speed < 0)
		ASensitivity = 0;

	while(abs(nMotorEncoder[Right1]) < abs(distance))
	{ //While the robot has not moved the desired distance
	
		//Get ultrasonic values in inches
		FrontUS = HTSPBreadADC(HTSPB, 2, 10)/1023.0*3.3*1000.0/6.4;
		BackUS = HTSPBreadADC(HTSPB, 3, 10)/1023.0*3.3*1000.0/6.4;
		
		//Calculate the average distance the robot is from the wall
		dist = (FrontUS + BackUS)/2.0 - space;
		
		//Calculate the severity of the angle of the robot to the wall
		angle = BackUS - FrontUS;
		
		//Displays for debugging
		nxtDisplayTextLine(1, "Dist %.1f", dist);
		nxtDisplayTextLine(2, "Angle %.1f", angle);
		nxtDisplayTextLine(3, "Front %.1f", FrontUS);
		nxtDisplayTextLine(4, "Back %.1f", BackUS);

		//Set speed of the robot's wheels, turning it to the desired position away from  
		//the wall in relation to the robot's angle and distance from wall
		motor[Left1] = speed + (dist*DSensitivity - angle*ASensitivity) * speed/ abs(speed);
		motor[Right1] = speed + (angle*ASensitivity - dist*DSensitivity) * speed/ abs(speed);
	}
	StopMotors();

}

//
//Drives centering the robot on an object such as a tube
//Uses two ultasonic sensors mounted on front of the robot
//
void FrontUltrasonicDriving(int speed, float distance, float Sensitivity)
{
	distance = 1120.0 * distance / circumference; //converts inches to encoder values
	
	//Calculate ultrasonic sensor values in inches
	float LInputData = HTSPBreadADC(HTSPB, 0, 10)/1023.0*3.3*1000.0/6.4;
	float RInputData = HTSPBreadADC(HTSPB, 1, 10)/1023.0*3.3*1000.0/6.4;
	
	nMotorEncoder[Right1] = 0;
	while(nMotorEncoder[Right1] < distance)
	{ //while robot has not traveled desired distance
	
		//Calculate ultrasonic sensor values in inches
		LInputData = HTSPBreadADC(HTSPB, 0, 10)/1023.0*3.3*1000.0/6.4;
		RInputData = HTSPBreadADC(HTSPB, 1, 10)/1023.0*3.3*1000.0/6.4;

		nxtDisplayTextLine(1, "%.1d", RInputData);
		nxtDisplayTextLine(2, "%.1d", LInputData);

		//Ajdust wheel speeds to center object with robot
		motor[Left1] = speed-(LInputData-RInputData)*Sensitivity;
		motor[Right1] = speed-(RInputData-LInputData)*Sensitivity;
	}
	StopMotors();

}

//
//Drives centering the robot on an object such as a tube
//Uses two ultasonic sensors mounted on front of the robot
//Stops based on time rather than encoder values
//
void TimeUltrasonicDriving(int speed, long Time, float Sensitivity)
{
	//calculate ultrasonic sensor values in inches
	float LInputData = HTSPBreadADC(HTSPB, 0, 10)/1023.0*3.3*1000.0/6.4;
	float RInputData = HTSPBreadADC(HTSPB, 1, 10)/1023.0*3.3*1000.0/6.4;
	
	nMotorEncoder[Right1] = 0;
	ClearTimer(T3);
	
	while(time1[T3] < Time)
	{ //while desired time has not passed
		
		//calculate ultrasonic sensor values in inches
		LInputData = HTSPBreadADC(HTSPB, 0, 10)/1023.0*3.3*1000.0/6.4;
		RInputData = HTSPBreadADC(HTSPB, 1, 10)/1023.0*3.3*1000.0/6.4;

		nxtDisplayTextLine(1, "%.1d", RInputData);
		nxtDisplayTextLine(2, "%.1d", LInputData);

		//Ajdust wheel speeds to center object with robot
		motor[Left1] = speed-(LInputData-RInputData)*Sensitivity;
		motor[Right1] = speed-(RInputData-LInputData)*Sensitivity;
	}
	StopMotors();
}

void TurnInPlace2(State Control, int speed, int degrees, Direction TurnDirection)
{
	LastDirection = 0.0;
	ClearTimer(T1);
	wait1Msec(100);
	int EncValue;
	float distance;
	tMotor MotorValuePos1;
	tMotor MotorValueNeg1;
	int CurrEncValueLeft;            //current value of the left encoder
	int CurrEncValueRight;           //current value of the right encoder
	int EncValueMax = 0;             //maximum encoder value recieved
	bool EncValueExceeded = false;   //state if the encoder value has been exceeded
	bool exitLoop = false;           //state determining whether the loop should be exited
	float StartHeading = GetAngle();
	float EndHeading;
	ExitState Exit;
	float GyroHeading = GetAngle();

	ClearTimer(T3);
	distance = ((float) degrees / Degrees2Inches) / 4.0;
	EncValue = 1120.0 * distance / circumference;  //Converts degrees into encoder value

	//Determine configuration for different turn directions
	if (TurnDirection==Left)
	{ //Left wheel will move backwards, front forwards
		MotorValueNeg1 = Left1;
		MotorValuePos1 = Right1;
		EndHeading = (GyroHeading - degrees);
	}
	else
	{ //Left wheel will move forwards, front backwards
		MotorValueNeg1 = Right1;
		MotorValuePos1 = Left1;
		EndHeading = (GyroHeading + degrees);
	}

	//Reset and initialize values
	EncValue = EncValue*(GearRatio);
	nMotorEncoder[MotorValuePos1] = 0;
	nMotorEncoder[MotorValueNeg1] = 0;

	CurrEncValueLeft = nMotorEncoder[Left1];
	CurrEncValueRight = nMotorEncoder[Right1];
	motor[MotorValuePos1] = speed;
	motor[MotorValueNeg1] = -speed;

	while(!exitLoop)
	{ //while distance not reached
		CurrEncValueLeft = nMotorEncoder[Left1];
		CurrEncValueRight = nMotorEncoder[Right1];
		GyroHeading = GetAngle();

		if(Control == Robot)
		{ // Control by encoders
			if(abs(CurrEncValueLeft) > abs(EncValue))
			{  // if the distance is reached

				if(EncValueExceeded &&(EncValueMax != CurrEncValueLeft))
					exitLoop = true;
				else
				{
					EncValueMax = CurrEncValueLeft;
					EncValueExceeded = true;
				}
			} // end if the distance is reached
			else
				EncValueExceeded = false;
		} // end Control by encoders
		else if(Control == Gyro)
		{ // control by gyroscopic sensor

			// if turn is complete
			if(abs(FixDirection(GyroHeading)-FixDirection(StartHeading)) > degrees)
			{
				nxtDisplayTextLine(2, "%.1d", GyroHeading);
				nxtDisplayTextLine(3, "%.1d", StartHeading);
				exitLoop = true;
				Exit = Regular;
			}
		}// end control by gyroscopic sensor
	} //while distance not matched

	StopMotors();
	//return(Exit);
} // end TurnInPlace2

//
//Allows drivers to select a delay and where the robot is starting
//
void initializeRobot()
{
	TButtons nBtn;
	StopTask(displayDiagnostics);

	//initialize protobaord sensors
	HTSPBsetupIO(HTSPB, 0b00000001);

	//	HTSPBwriteIO(HTSPB, 0b00000000);
	//	wait1Msec(50);
	HTSPBwriteIO(HTSPB, 0b00000001);
	//	wait1Msec(10);
	//	HTSPBsetupIO(HTSPB, 0b00000000);

	ClearTimer(T1);
	
	//User chooses how long to delay before program begins
	nxtDisplayTextLine(0, "Delay:");
	nxtDisplayTextLine(1, "Left for Less  <-");
	nxtDisplayTextLine(2, "Right for More ->");
	nxtDisplayTextLine(4, "Seconds = 0");

	ClearTimer(T4);
	while(!DelaySelected)
	{
		while (true) // wait for button press
		{
			nBtn = nNxtButtonPressed;
			if (nBtn != -1)
				break;
		}

		switch (nBtn)
		{
		case kLeftButton: //if the left button is pressed, subtact from the delay value
			if (time1[T4] > 200)
			{
				ClearTimer(T4);
				Delay--;
				if(Delay < 0)
					Delay = 0;
				nxtDisplayTextLine(4, "Seconds = %d", Delay);
			}
			break;

		case kRightButton: //if the right button is pressed, add to the delay value
			if (time1[T4] > 200)
			{
				ClearTimer(T4);
				Delay++;
				if(Delay > 30)
					Delay = 30;
				nxtDisplayTextLine(4, "Seconds = %d", Delay);
			}
			break;

		case kEnterButton: DelaySelected = true;    break;
		case kExitButton:   ++nExitButton;        break;
		default:            ++nNoButton;          break;
		}
	}// end while !DelaySelected

	wait1Msec(500);

	//User chooses where the robot will start
	nxtDisplayTextLine(0, "Start:");
	nxtDisplayTextLine(1, "Left for Ground  <-");
	nxtDisplayTextLine(2, "Right for Ramp ->");
	nxtDisplayTextLine(4, "Is is a Verb ;)");

	while(!StartSelected)
	{
		while (true) // wait for button press
		{
			nBtn = nNxtButtonPressed;
			if (nBtn != -1)
				break;
		}

		switch (nBtn)
		{
		case kLeftButton: //if the right button is pressed, start is on the ground
			StartSelected = true;
			Start = ground;
			break;

		case kRightButton: //if the right button is pressed, start is on the ramp
			StartSelected = true;
			Start = ramp;
			break;

		case kEnterButton: DelaySelected = true;    break;
		case kExitButton:   ++nExitButton;        break;
		default:            ++nNoButton;          break;
		}
	} //end while !DelaySelected
	
	//User chooses whether the robot should anticipate defense
	PlaySound(soundFastUpwardTones);
	wait1Msec(500);
	nxtDisplayTextLine(0, "Defense?");
	nxtDisplayTextLine(1, "Left for Yes  <-");
	nxtDisplayTextLine(2, "Right for No ->");
	nxtDisplayTextLine(4, "Is is a Verb ;)");

	while(!DefenseSelected)
	{
		while (true) // wait for button press
		{
			nBtn = nNxtButtonPressed;
			if (nBtn != -1)
				break;
		}

		switch (nBtn)
		{
		case kLeftButton:
			DefenseSelected = true;
			Defense = true;
			break;

		case kRightButton: 
			DefenseSelected = true;
			Defense = false;
			break;

		case kEnterButton: DelaySelected = true;    break;
		case kExitButton:   ++nExitButton;        break;
		default:            ++nNoButton;          break;
		}
	} //end while !DelaySelected
	PlaySound(soundFastUpwardTones);
} //end initialize robot

//
//Drive forward or backward
//Adjusts to natural rift if encoders sense any
//
ExitState DriveStraight(int speed, float distance, int correction)
{
	long EncValue;                 // # of encoder ticks corresponding to distance
	long CurrEncValueLeft;         //current value of the left encoder
	long CurrEncValueRight;        //current value of the right encoder
	float Sensitivity = 0.2;       //multiplying factor of adjustion
	int RightSpeed;                //calculated speed of right motor
	int LeftSpeed;                 //calculated speed of left motor
	long EncValueMax = 0;          //maximum encoder value recieved
	bool EncValueExceeded = false; //state if the encoder value has been exceeded
	bool exitLoop = false;         //state determining whether the loop should be exited
	int MinSpeed = 50;
	ExitState Exit;
	if(MinSpeed>speed)
		MinSpeed = speed;

	ClearTimer(T3);

	nMotorEncoder[Left1] = 0;                // Reset the Motor Encoder of Motor B.
	nMotorEncoder[Right1] = 0;                // Reset the Motor Encoder of Motor C.
	wait1Msec(100);

	EncValue = 1120.0 * distance / circumference;

	CurrEncValueLeft = 0;
	CurrEncValueRight = 0;

	while(!exitLoop)
	{ //while distance not matched
		nxtDisplayTextLine(4, "Right Encoder %.1d", nMotorEncoder[Right1]);
		nxtDisplayTextLine(5, "Left Encoder %.1d", nMotorEncoder[Left1]);

		//If the wheels are not turning, stop them to prevent motor burnouts
		if(time1[T3] > 300)
		{

			ClearTimer(T3);
			if((CurrEncValueLeft == LastEncoderValueLeft) || (CurrEncValueRight == LastEncoderValueRight))
			{
				Exit = MotorStopped;
				exitLoop = true;
			}
			else
			{
				LastEncoderValueLeft = CurrEncValueLeft;
				LastEncoderValueRight = CurrEncValueRight;
			}
		}
		
		//Drive straight, adjusting for natural drift of the robot
		if(abs(CurrEncValueLeft) > abs(CurrEncValueRight))
		{
			LeftSpeed = (speed - (CurrEncValueLeft - CurrEncValueRight)*Sensitivity);
			RightSpeed = speed;
		}
		else if(abs(CurrEncValueLeft) < abs(CurrEncValueRight))
		{
			RightSpeed = (speed - (CurrEncValueRight - CurrEncValueLeft)*Sensitivity);
			LeftSpeed = speed;
		}
		else
		{
			RightSpeed = speed;
			LeftSpeed = speed;
		}
		
		//If drifting instead of driving straight, don't correct for natural drift
		if(correction != 0)
		{
			RightSpeed = speed;
			LeftSpeed = speed;
		}
		
		//Set motor speeds
		motor[Right1] = RightSpeed + correction;
		motor[Left1] = LeftSpeed - correction;
		
		//Update encoder values
		CurrEncValueLeft = -nMotorEncoder[Left1];
		CurrEncValueRight = nMotorEncoder[Right1];
		
		if(abs(CurrEncValueRight) > abs(EncValue))
		{  // if the distance is reached
			if(EncValueExceeded &&(EncValueMax != CurrEncValueRight))
			{ //if two consecutive different values over the distance are detected
				exitLoop = true;
				Exit = Regular;
			}
			else
			{
				EncValueMax = CurrEncValueRight;
				EncValueExceeded = true;
			}
		} // end if the distance is reached
		else
			EncValueExceeded = false;

		EndTimeSlice();

	} // end while distance not matched

	motor[Right1] = 0; //stop motors
	motor[Left1] = 0;

	//LastEncValue = CurrEncValueLeft;
	wait1Msec(500);

	return(Exit);
} // end EncoderDriveStraight


//
//Move the lifter to the height of the shortest tube
//
task LiftLifterBaby()
{
	nMotorEncoder[Lift] = 0;
	while(abs(nMotorEncoder[Lift]) < 3000)
	{
		nxtDisplayTextLine(7, "Lifter %.1d", nMotorEncoder[Lift]);
		motor[Lift] = 100;
	}
	motor[Lift] = 0;
}

//
//Lifts lifter to the height of the 60 cm tube
//
task LiftLifterMama()
{
	nMotorEncoder[Lift] = 0;
	while(abs(nMotorEncoder[Lift]) < 5000)
	{
		nxtDisplayTextLine(7, "Lifter %.1d", nMotorEncoder[Lift]);
		motor[Lift] = 100;
	}
	motor[Lift] = 0;
}

//
//Lifts from the height of the 60 cm tube to the 90 cm tube
//
task LiftLifterPapa()
{
	nMotorEncoder[Lift] = 0;
	while(abs(nMotorEncoder[Lift]) < 2200)
	{
		nxtDisplayTextLine(7, "Lifter %.1d", nMotorEncoder[Lift]);
		motor[Lift] = 100;
	}
	motor[Lift] = 5;
}

//
//Lifts from the height of the 90" tube to the 120" tube
//
task LiftLifterCenter()
{
	nMotorEncoder[Lift] = 0;
	while(abs(nMotorEncoder[Lift]) < 10000)
	{
		nxtDisplayTextLine(7, "Lifter %.1d", nMotorEncoder[Lift]);
		motor[Lift] = 100;
	}
	motor[Lift] = 5;
}

//
//Lower lifter from the 120" tube to a reasonable height for driving
//
task LowerLifterCenter()
{
	StopTask(LiftLifterCenter);
	nMotorEncoder[Lift] = 0;
	nxtDisplayTextLine(7, "Lifter %.1d", nMotorEncoder[Lift]);
	motor[Lift] = -50;
	wait1Msec(2000);
	motor[Lift] = 5;
}

task main()
{
	StopTask(displayDiagnostics);
	servo[Spout] = 20;
	int LeftDir = 0;
	int _strEnh;
	int _dirEnh;
	int LeftSpeed;
	int RightSpeed;
	int acS1, acS2, acS3, acS4, acS5;
	servo[IRBeam] = 200;

	/*	while(true)
	{	//test sensors
	HTIRS2readEnhanced(HTIR, LeftDir, _strEnh);
	nxtDisplayTextLine(1, "LIR %.1d", LeftDir);
	nxtDisplayTextLine(4, "Right %3d", HTSPBreadADC(HTSPB, 0, 10)/1023.0*3.3*1000.0/6.4);
	nxtDisplayTextLine(5, "Left %.1d", HTSPBreadADC(HTSPB, 1, 10)/1023.0*3.3*1000.0/6.4);
	//nxtDisplayTextLine(6, "Lifter  %.1d", nMotorEncoder[Lift]);
	} */

	float LInputData = HTSPBreadADC(HTSPB, 0, 10)/1023.0*3.3*1000.0/6.4;
	float RInputData = HTSPBreadADC(HTSPB, 1, 10)/1023.0*3.3*1000.0/6.4;

	servo[RightLatch] = 255;
	servo[LeftLatch] = 0;
	while(LInputData < 1 || RInputData < 1)
	{ //warns if there is a problem with sensors
		LInputData = HTSPBreadADC(HTSPB, 0, 10)/1023.0*3.3*1000.0/6.4;
		RInputData = HTSPBreadADC(HTSPB, 1, 10)/1023.0*3.3*1000.0/6.4;
		PlaySound(soundBeepBeep);
	}

	servo[Door] = 10;
	servo[Jumper] = 170;

	initializeRobot();
	motor[Yellow] = 100;

	//waitForStart();

	LastDirection = 0;

	nMotorEncoder[Lift] = 0;
	if(Start == ground)
	{//of starting on the ground, score in center tube and kick down kickstand
		ClearTimer(T2);
		
		//Calculate ultrasonic sensor values in inches
		LInputData = HTSPBreadADC(HTSPB, 0, 10)/1023.0*3.3*1000.0/6.4;
		RInputData = HTSPBreadADC(HTSPB, 1, 10)/1023.0*3.3*1000.0/6.4;
		
		//
		//Determine which position the center structure is in based on ultrasonic values
		//Then begin program acocrdingly
		//
		if (abs(LInputData - RInputData) > 1.5 && (LInputData + RInputData) > 80)
		{ //Center structure in position 2
			CenterPos = 2;
			DriveStraight(100, 5, 0);
			TurnInPlace2(Gyro, 75, 45, Left);
			DriveStraight(100, 38, 0);
			TurnInPlace2(Gyro, 75, 68, Right);
		}
		else
		{//Center structure not in position 2
			if (RInputData > 45)
			{
				CenterPos = 1;
				CenterPos = 1;
				DriveStraight(100, 7,0);
				TurnInPlace2(Gyro, 75, 30, Left);
				DriveStraight(100, 60,0);
				TurnInPlace2(Gyro, 75, 90, Right);
			}
			else
			{
				CenterPos = 3;
			}
		}//End enter structure not in position 2
		
		nxtDisplayTextLine(4, "%.1d", CenterPos);
		nxtDisplayTextLine(5, "R %.1d", RInputData);
		nxtDisplayTextLine(6, "L %.1d", LInputData);
		
		servo[IRBeam] = 100;
		StartTask(LiftLifterCenter);
		wait1Msec(4500);
		servo[IRBeam] = 200;

		while(USreadDist(LEGOUS) > 28)
		{ //While not yet reached center structure
		
			//Read the IR sensor
			HTIRS2readEnhanced(HTIR, _dirEnh, _strEnh);
			
			//Center in on the IR beacon based on IR sensor values
			if(_dirEnh > 6)
			{
				LeftSpeed = 50;
				RightSpeed = 20;
			}
			else if(_dirEnh < 6)
			{

				RightSpeed = 50;
				LeftSpeed = 20;
			}
			else
			{ //If on zone 6
			
				//Read IR sensor
				HTIRS2readAllACStrength(HTIR, acS1, acS2, acS3, acS4, acS5);
				HTIRS2readEnhanced(HTIR, LeftDir, _strEnh);

				if(acS3 > acS4)
				{
					RightSpeed = 50- ((float)(acS3 - acS4)*0.1);
					LeftSpeed = 50;
				}
				else if(acS3 < acS2)
				{
					LeftSpeed = 50- ((float)(acS4 - acS3)*0.1);
					RightSpeed = 50;
				}
				else
				{
					RightSpeed = 50;
					LeftSpeed = 50;
				}
			}// end if on zone 4
			motor[Right1] = RightSpeed;
			motor[Left1] = LeftSpeed;
		}

		motor[Right1] = 0;
		motor[Left1] = 0;
		
		//Drop balls in center structure tube
		wait1Msec(500);
		servo[Door] = 55;
		wait1Msec(2000);
		
		DriveStraight(-30, 10, 0);
		servo[IRBeam] = 100;

		StartTask(LowerLifterCenter);

		wait1Msec(1500);
		if(Defense)
		{ //Block other robot instead of kicking down the kickstand
			if(CenterPos == 3)
			{
				TurnInPlace2(Gyro, 100, 50, Left);
				DriveStraight(100, 40, 0);
			}
			if(CenterPos == 2)
			{
				TurnInPlace2(Gyro, 100, 60, Left);
				DriveStraight(100, 20, 0);
			}
		}
		else
		{//Move to kick down the kickstand
			TurnInPlace2(Gyro, 100, 50, Right);
			DriveStraight(100, 15, 0);
			TurnInPlace2(Gyro, 100, 65, Left);
			while(time1[T2] < 25000)
					wait1Msec(1);
			DriveStraight(100, 25, 0);
		}
		
		//prevent program from ending to keep power to servos
		WaitForButton();
	}
	else //starting on ramp
	{ //place ball in 2 tubes and bring them to parking zone

		servo[IRBeam] = 100;
		servo[Spout] = 255;
		
		//drive down ramp
		DriveStraight(40, 50, 3);
		servo[Jumper] = 50;
		
		//Calculate ultrasonic sensor values in inches
		LInputData = HTSPBreadADC(HTSPB, 0, 10)/1023.0*3.3*1000.0/6.4;
		RInputData = HTSPBreadADC(HTSPB, 1, 10)/1023.0*3.3*1000.0/6.4;
		
		if(Defense == true && (LInputData < 20 || RInputData < 20))
		{ //If anticipating defesne and being blocked
			Defended = true;
			ClearTimer(T2);
			
			while((time1[T2] < 5000) && (LInputData < 20 || RInputData < 20))
			{ //Wait for other robot to move
				LInputData = HTSPBreadADC(HTSPB, 0, 10)/1023.0*3.3*1000.0/6.4;
				RInputData = HTSPBreadADC(HTSPB, 1, 10)/1023.0*3.3*1000.0/6.4;
				nxtDisplayTextLine(1, "Left %.1d", LInputData);
				nxtDisplayTextLine(2, "Right %.1d", RInputData);
			}
			
			if(LInputData < 15 || RInputData < 15)
			{ //If defending robot doesn't move, initiate backup plan
				StartTask(LiftLifterBaby);
				TurnInPlace2(Gyro, 100, 90, Left);
				DriveStraight(100, 25, 0);
				TurnInPlace2(Gyro, 100, 70, Right);
				DriveStraight(100, 20, 0);
				MoveLatches(Open);
				TimeUltrasonicDriving(60, 1800, 7);

				wait1Msec(500);
				servo[Door] = 30;
				wait1Msec(500);
				DriveStraight(-80, 15, 0);
				MoveLatches(Closed);
				TurnInPlace2(Gyro, 100, 40, Right);
				nMotorEncoder[Lift] = 0;

				while(abs(nMotorEncoder[Lift]) < 5200)
				{
					nxtDisplayTextLine(7, "Lifter %.1d", nMotorEncoder[Lift]);
					motor[Lift] = 100;
				}
				motor[Lift] = 0;
				MoveLatches(Open);
				TimeUltrasonicDriving(60, 1800, 7.2);
				MoveLatches(Closed);

				wait1Msec(700);
				servo[Door] = 55;
				WaitForButton();
			}
		}

		StartTask(LiftLifterMama);
		wait1Msec(1000);
		MoveLatches(Open);

		//Drive to 60 cm tube
		SideUltrasonicDriving(100, 20.4, 7.0);
		FrontUltrasonicDriving(100, 26.0, 3);
		MoveLatches(Closed);

		//Place 60 cm tube out of the way
		wait1Msec(800);
		servo[Door] = 30;
		wait1Msec(500);
		SideUltrasonicDriving(-100, -18.67, 7.5);
		TurnInPlace2(Gyro, 100, 140, Left);

		StartTask(LiftLifterPapa);


		DriveStraight(100, 8, 0);
		MoveLatches(Open);

		//Get robot back on the path to score
		DriveStraight(-60, 9.3, 0);
		//	MoveLatches(Closed);

		TurnInPlace2(Gyro, 100, 95, Right);
		//	MoveLatches(Open);

		//Move to 90 cm tube
		TimeUltrasonicDriving(50, 2150, 5);

		MoveLatches(Closed);

		//Bring tubes to parking zone
		SideUltrasonicDriving(-100, -13.87, 7.5);
		wait1Msec(800);
		servo[Door] = 55;
		wait1Msec(800);
		
		if(!Defended)
		{ //don't travel across field if defense encountered earlier
			TurnInPlace2(Gyro, 100, 4, Right);
			DriveStraight(-100, 100, 0);
			TurnInPlace2(Gyro, 100, 140, Right);

		}
		WaitForButton();
	} //end if starting on ramp
}//end task main
# MMCascadeEffect 
